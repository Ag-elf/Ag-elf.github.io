{"meta":{"title":"给予艾欧泽亚以救济","subtitle":"エオルゼアに、救済を...","description":"FFXIV Lovers | Coder","author":"时雨牧流萤","url":"https://ag-elf.github.io","root":"/"},"pages":[{"title":"这里是所有的类别","date":"2021-04-28T08:38:28.358Z","updated":"2021-04-28T08:38:28.358Z","comments":false,"path":"category/index.html","permalink":"https://ag-elf.github.io/category/index.html","excerpt":"","text":""},{"title":"这里是标签页","date":"2021-04-28T08:38:21.834Z","updated":"2021-04-28T08:38:21.834Z","comments":false,"path":"tags/index.html","permalink":"https://ag-elf.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"0x08 - Docker小鲸鱼的使用笔记 [2] 自动化的第一步 with Jenkins","slug":"0x08-Docker-Usage-Jenkins","date":"2021-05-30T06:42:52.000Z","updated":"2021-05-30T07:31:55.763Z","comments":true,"path":"2021/05/30/0x08-Docker-Usage-Jenkins/","link":"","permalink":"https://ag-elf.github.io/2021/05/30/0x08-Docker-Usage-Jenkins/","excerpt":"","text":"自动化难题当你完成了代码的提交，当你重新又反复地进行着，搭建镜像，上传镜像，运行容器的操作，你是否发觉这一切重复的劳作让人有点疲惫。 如果说，能够在完成了代码开发工作后，将代码 push 到云上的托管仓库时，就可以自动进入流程，让计算机托管完成上述的一切任务，那开发工作也会变得惬意而轻松。 诚然，我们可以写一个简单的 shell 脚本： 12345$ docker build -t myApps:v1.0 .$ docker login --username=yourname your.registry.address.com$ docker tag myApps:v1.0 your.registry.address.com/myApps:v1.0$ docker push your.registry.address.com/myApps:v1.0$ docker rmi your.registry.address.com/myApps:v1.0 它就可以半自动地将代码打包成镜像并装入线上的镜像仓库。可是这样的方法让代码管理成为了一个头疼的问题。 如果说可以在线上进行这一切的操作，包括测试和代码审查，能将这一切的流程进行自动化处理，那么对于后续的开发工作来说，可以提升相当大的开发效率。 于是请到今天的主角，Jenkins，一款好用的开源持续集成工具。 工作流程我们想要的解决的问题是，希望将从代码提交至部署运行之间的所有流程，让 Jenkins 帮我们做自动化处理。 那么简单来说，可以将步骤整理成下面这个样子： 通过 Git 提交代码到 Gitee。 触发 Gitee 的提交 hook ，会向指定的地址发送一个 post 请求。 让 Jenkins 获取这个 post 请求， 然后 Jenkins 在本地服务器上将程序打包并上传至云上镜像。 通知集群，并更新至最新的镜像。 0x00 从安装开始安装 Jenkins 并不是一件特别难的事，请看这里。选择正确的版本安装，以及正确地配置环境即可。 这里嘛 ~ 以后想起来的话会贴一些可能需要注意的事项。 0x01 配置 Jenkins施工中","categories":[{"name":"技术","slug":"computer-science","permalink":"https://ag-elf.github.io/category/computer-science/"},{"name":"Docker","slug":"computer-science/Docker","permalink":"https://ag-elf.github.io/category/computer-science/Docker/"}],"tags":[{"name":"Docker","slug":"Docker","permalink":"https://ag-elf.github.io/tags/Docker/"},{"name":"Jenkins","slug":"Jenkins","permalink":"https://ag-elf.github.io/tags/Jenkins/"}]},{"title":"0x07 - Docker小鲸鱼的使用笔记 [1] 从无到有","slug":"0x07-Docker_Usage","date":"2021-05-24T08:54:11.000Z","updated":"2021-05-30T07:12:24.494Z","comments":true,"path":"2021/05/24/0x07-Docker_Usage/","link":"","permalink":"https://ag-elf.github.io/2021/05/24/0x07-Docker_Usage/","excerpt":"","text":"Docker? Docker!Docker，码头工人，搬运工，承运者，可爱的小鲸鱼。 简单来说 Docker 是一个开源的应用容器引擎。开发者把应用，软件还有相应依赖通过 Docker 打包成一个轻量级、可移植的容器，只要目标机器拥有 Docker 的运行环境，不用关心内部的依赖即可方便完成应用分发和发布工作，非常适用于集群环境，既节约开销，也方便部署。 它如何工作？对于 Docker 来说，其整体的框架结构像这样： 首先，我们将应用打包为一个又一个的 IMAGE；然后，在需要运行时，我们将这些镜像提取出来，创建一个对应的 CONTAINER 来运行它；而这个打包好的 IMAGE 存储的地方，就叫做 REGISTRY。 因此运行的流程可以概括如下： 从 REGISTRY 获取 IMAGE 创建一个 CONTAINER。 将 IMAGE 放入 CONTAINER 运行。 同一个 IMAGE 可以创建千千万万个 CONTAINER。同一个 REGISTRY 可以存放许许多多的 IMAGE。而一个 CONTAINER 一次尽量只运行一个 IMAGE。 似乎会有人将 CONTAINER 当作是虚拟机来理解，但是在这里，CONTAINER 更像是一个独立的进程，而非是一个虚拟机。 因此如果需要多容器运行，请使用 docker-compose 工具进行管理。 如何开始Reference:当然，Docker 的项目网址还有文档其实非常清晰明了。如果对英文比较苦手，一些成品文档，例如 runoob 也是不错的去处。 这里只是拾人牙慧，总结了一些自己在 Docker 使用过程中的经验。 那么，让我们开始吧—— 0x00 安装Linux广大的 Linux 用户只需要运行以下内容： 1$ curl -fsSL https://get.docker.com | bash -s docker --mirror Aliyun # 当然，Aliyun 是可选的 等待着一切安装完成——然后让我们来看看成果： 1$ docker -v Ok，你已经准备好下一步了。 WindowsWindows 下的 Docker 可以在 这里 找到。像是一般软件一样点击下一步安装完成后，小鲸鱼会出现在你的通知栏。 这样，你就可以在 Windows 下使用 Docker 了。 PS. 小鲸鱼偏好 Linux，在 Windows 下运行会额外消耗资源，且需要安装 WSL （Windows Subsystem for Linux）来承载运行。 MacOSMacOS 我们可以使用 Homebrew 来安装 Docker。 1$ brew install --cask --appdir=/Applications docker 和 Windows 一样，安装完成后小鲸鱼会出现在你的状态栏。 Enjoy ~ 0x01 Hello WorldDocker 的 Hello World 分为两步： 将应用打包为 Docker Image 将 Docker Image 放入 Docker Container 运行 1. 打包首先，让我们建立一个简单的应用。 假设我们的应用如下：我们希望运行 Docker后，在屏幕上打印下 Hello World。 那么实际操作的流程如下 运行 123$ mkdir helloWorld$ cd helloWorld$ vi run.sh 并保存以下命令 1$ echo &quot;Hello world&quot; 在当前文件夹下新建一个 Dockerfile注意！很多关于镜像的设置都基于 Dockerfile ，这里先简单略过。关于 Dockerfile 的编写，请看这里。 1$ vi Dockerfile 然后让我们在 Dockerfile 里添加如下的信息： 123456789FROM ubuntu # 这是告诉 Docker, 这个镜像基于什么构建，所有的 Docker 镜像都需要这么一行命令 # 不同的应用基于不同的镜像，这里由于我们只用了一些基础命令，所以 ubuntu 镜像即可MAINTAINER Shigure_Hotaru # 维护人，也就是作者ADD . /code # 将文件夹内的东西 Copy 到 镜像中 /code 文件夹内WORKDIR /code # 相当于 cd /code RUN echo &quot;Echo Before Running The Docker Image&quot; # RUN 修饰的命令表示在 &quot;构建镜像&quot; 时运行的命令CMD sh run.sh # CMD 修饰的命令表示在 &quot;运行镜像&quot; 时运行的命令 准备就绪以后这样运行： 1$ sudo docker build -t hw:v1.0 . # -t 表示 tag，可以理解为是版本号，在 hw 冒号后的就是版本信息了，最后的 . 表示当前文件夹 Docker 会把你在 Dockerfile 里写入的步骤，一步步执行。 我们关注一下第 5 步： 1234Step 5&#x2F;6 : RUN echo &quot;Echo Before Running The Docker Image&quot; ---&gt; Running in b0446bd5ad97Echo Before Running The Docker ImageRemoving intermediate container b0446bd5ad97 这一步就相当于是运行 RUN 后的命令。假如有需要安装依赖，或者在运行前进行的准备工作，都可以用 RUN 修饰完成。 在完成了镜像构建以后，让我们看看我们的新镜像： 1234$ sudo docker imagesREPOSITORY TAG IMAGE ID CREATED SIZEhw v1.0.0 54c64c094be8 7 minutes ago 72.7MBubuntu latest 7e0aa2d69a15 4 weeks ago 72.7MB 可以看到我们的镜像除了 hw 以外，还有一个 ubuntu 镜像，这个就是我们 hw 基于的原始镜像了。 如果要移除镜像： 12$ sudo docker rmi hw:v1.0.0$ sudo docker rmi 54c64c094be8 # 使用镜像 ID 也可删除镜像 2. 运行其实 Docker 的运行十分简单： 12$ sudo docker run hw:v1.0.0 # 在新容器中运行 hw:v1.0.0 的镜像Hello World 在这里我们没有用上各种各样的额外设置，下表总结了一些可能会用上的选项，更全的列表 请看这里 1234567docker run [OPTIONS] IMAGE [COMMAND] [ARGS...] -d 后台运行该镜像 -i 以交互模式运行容器，一般与 -t 一起使用 -t 分配一个伪输入端口，一般与 -i 一起使用 -p 指定端口映射，格式：主机(宿主)端口:容器端口 例如： docker run -p 1234:5000 hw:v1.0.0 将暴露容器的 5000 端口，并将主机的 1234 端口映射到上面 ... 在执行时，Docker 会给这个镜像分配一个容器，我们可以通过下面的命令来查看正在运行的容器： 123$ sudo docker ps -aCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES0c7d9897897d hw:v1.0.0 &quot;/bin/sh -c &#x27;sh run.…&quot; 20 seconds ago Exited (0) 19 seconds ago kind_ardinghelli 可以看到这个容器已经执行结束，假如我们需要知道执行过程中的日志信息，我们需要这样做： 12$ sudo docker logs 0c7d9897897dHello World 如果要把容器移除的话，需要这样执行： 12$ sudo docker rm 0c7d9897897d0c7d9897897d 以上，你已经学会如何正确驾驶小鲸鱼了；现在，开始你最伟大的远航吧 ~ 之后的事事实上，如果要把一个镜像从无到有，从代码到镜像，放入容器，最后再从外部访问这个服务，中间涉及到的过程十分复杂，不仅需要搭配合适的网关网口，还需要注意各种端口转发和服务框架。 最后涉及到业务的逻辑，还有一些部署时的杂事，也让人十分头疼。 小鲸鱼虽然脾气不大，但是运送小鲸鱼的人可是十足的难缠。 从搭建环境开始，到上传至云上的 Repository ，再到最后的部署落地，不仅命令繁多，其中的过程也称不上简单。 那么该如何将这一切处理成流水线，成为 Docker 达人呢？ 其实社区已经给出了不错的答案，下一次让我们来尝试一下，Jenkins x Docker 的解决方案。","categories":[{"name":"技术","slug":"computer-science","permalink":"https://ag-elf.github.io/category/computer-science/"},{"name":"Docker","slug":"computer-science/Docker","permalink":"https://ag-elf.github.io/category/computer-science/Docker/"}],"tags":[{"name":"Docker","slug":"Docker","permalink":"https://ag-elf.github.io/tags/Docker/"}]},{"title":"0x06 - 聚类算法 - 我从哪里来，又到哪里去","slug":"0x06-Clustering","date":"2021-05-13T01:43:43.000Z","updated":"2021-05-14T02:46:41.383Z","comments":true,"path":"2021/05/13/0x06-Clustering/","link":"","permalink":"https://ag-elf.github.io/2021/05/13/0x06-Clustering/","excerpt":"","text":"聚类，Clustering今天遇到了一个需求，需要在二维平面上将相似（相近）的坐标归类到一起，好方便下一步的数据分析工作。 那么趁此机会，不如来说说不同聚类算法的，计算过程。 施工中 开始之前先来聊聊什么是聚类。 聚类是统计学上的概念，属于机器学习中的非监督学习。简单来说，应用这种算法的最根本目的就在于，让数据根据本身的特性进行分类，最终区分出同类与不同类的数据。 由于事先我们并不知道该如何分类处理这些数据，因此，我们并没有明确的分类准则。正因为这这样，我们需要数据本身来为我们提供划分标准，因而属于非监督学习。 0x00 K-Means0x01 Meanshift Clustering0x02 DBScan ClusteringDensity-based spatial clustering of applications with noise (DBSCAN) 0x03 Agglomerative Hierarchical Clustering","categories":[{"name":"技术","slug":"computer-science","permalink":"https://ag-elf.github.io/category/computer-science/"},{"name":"机器学习","slug":"computer-science/machine-learning","permalink":"https://ag-elf.github.io/category/computer-science/machine-learning/"}],"tags":[{"name":"Clustering","slug":"Clustering","permalink":"https://ag-elf.github.io/tags/Clustering/"}]},{"title":"0x05 - FFXIV - 02 - 捕鱼人","slug":"0x05-FFXIV-2","date":"2021-05-10T06:48:22.000Z","updated":"2021-05-19T01:57:22.497Z","comments":true,"path":"2021/05/10/0x05-FFXIV-2/","link":"","permalink":"https://ag-elf.github.io/2021/05/10/0x05-FFXIV-2/","excerpt":"","text":"0x00捕鱼人的清晨总是来得很早。擦拭着鱼竿，筹备着鱼饵，大清早奔赴钓场等待着合适的时机。 「嗯，今天也是个好天气~」 狂风呼啸的大海，电闪雷鸣，翻涌的波涛仿佛要把一切吞噬殆尽，红玉炮台的一隅岌岌可危。此情此景，捕鱼人露出了欣慰的笑容。 ……今天，红龙会出海。 0x01众所周知，魔大陆有三幻神，而我们的捕鱼人，也有四幻神，当然，说的是鱼。 东之红龙，西之沙皇；天之蝴蝶螺，湖之胸脊鲨。个个都身怀绝技，随随便便都是能脱的主。 当七彩天主的门票吃掉了第 10086 条嗡嗡石蝇后，几近破产的捕鱼人，最终决定放弃延夏旅游公司的往返三日游。 她把鱼竿晾了起来，拿起了许久未动的黑魔杖…… 据说后来，七彩沟每次荡漾起核爆的声响，都会有快乐的捕鱼人，还有端着的，烤熟了的七彩天主。 0x02红龙鲜少有浮出水面的一天，有时候甚至要等好几十天才能等到一个不错的窗口。 但是红龙是个死傲娇，如果让它起它就起，红龙就会很没面子。一般来说，需要邻家阿姨苦尔鳗大婶，苦苦给红龙介绍，红龙才会羞涩地从水里起来，轻轻拽一拽捕鱼人的钩。 因此，钓红龙是门技术活，耐心与恒心并存。 首先，在红龙开始活动前先用若干的鱼饵贿赂苦尔鳗大婶；睁一只眼闭一只眼的苦尔鳗大婶，这时候才有可能会去敲一敲红龙的门；而绝大多数时候，苦尔鳗大婶会一个人回来。这个时候就需要安抚一下苦尔鳗大婶，让它静下心来再去一次。 成为工具人的苦尔鳗大婶自然不会乐意，去过 2 ~ 3 次以后，苦尔鳗大婶也会愤而脱钩。在此之后，只能从头开始，用更多的鱼饵，更多的贿赂…… 当然，还有更多的苦尔鳗，和更多的脱钩…… 「在苦尔鳗套娃的循环中体验，更快，更高，更强的痛楚。」——来自加雷马帝国的某位不愿意透露姓名的资深捕鱼人。 「捕鱼人，可不适合在钓红龙时，露出脱钩的表情。」——来自伊修加德豪门的某位捕鱼人。 0x03建设伊修加德新农村，我辈义不容辞。 捕鱼人不知道为什么，就被拽上了去往云冠群岛的特快空艇。 云冠群岛的独特气候每 3 个多小时就会变更一次。这让，习惯了看早上天气，来预测下午天气的捕鱼人难以进行捕鱼作业。 “云海中可能会没有蜻蜓，没有狮鹫。”“但是莫莫拉莫拉的模样却依然会如期而至。” ——还有在一起的，奇奇怪怪，形形色色的不死鱼。","categories":[{"name":"碎碎念","slug":"small-talks","permalink":"https://ag-elf.github.io/category/small-talks/"},{"name":"FFXIV","slug":"small-talks/FFXIV","permalink":"https://ag-elf.github.io/category/small-talks/FFXIV/"}],"tags":[{"name":"FFXIV的故事","slug":"FFXIV的故事","permalink":"https://ag-elf.github.io/tags/FFXIV%E7%9A%84%E6%95%85%E4%BA%8B/"}]},{"title":"0x04 - Cassandra & Spark：[1] 从 Cassandra 开始的大数据处理之路","slug":"0x04-Cassandra-1","date":"2021-05-06T00:52:28.000Z","updated":"2021-05-13T01:58:12.395Z","comments":true,"path":"2021/05/06/0x04-Cassandra-1/","link":"","permalink":"https://ag-elf.github.io/2021/05/06/0x04-Cassandra-1/","excerpt":"","text":"从 Cassandra 开始的大数据处理之路每每遇到数据量过大的场景后，如何对海量数据进行处理就成了一个头疼的问题。使用关系型数据库时往往会遇到数据量大，表格离散，分区分表繁琐，难以简单处理等问题。在对数据读写量有海量需求的时候，使用 Cassandra 这样的 NoSQL 分布式数据库或许是一个合理的解决方案。 Cassandra 是什么所以 Cassandra 是什么呢？ Cassandra 是一套开源分布式 NoSQL 数据库系统， 它最初由 Facebook 开发，用于储存收件箱等简单格式数据。 集 GoogleBigTable 的数据模型与 Amazon Dynamo 的完全分布式的架构于一身， Facebook 于 2008 将 Cassandra 开源。 此后，由于 Cassandra 良好的可扩展性， 被 Digg、Twitter 等知名 Web 2.0 网站所采纳， 成为了一种流行的分布式结构化数据存储方案。 ------ From 百度百科 NoSQL （Not Only SQL） 即为非关系型的数据库。 为了应对网络应用场景下的高并发和大规模数据应用，Cassandra 应运而生，是为了解决大数据应用难题而诞生的数据库解决方案之一。 但是抛开华丽的外表， Cassandra 也只是一种存储数据的方法而已，如何去使用，如何去利用这些数据才是我们应该关心的事。 Cassandra 的不同之处 Cassandra 是分布式系统，在存储空间不够时，只需要增加节点就可以扩充存储空间。 而在使用关系型数据库，例如 mysql 时，它的单表数据量是有瓶颈的，当数据量到达一定级别，就需要考虑分库分表或者分区等。而这一点在 Cassandra 这里，仅需要增加节点就可以解决了，非常方便。 Cassandra 可以动态增删表的字段，这在大型项目的部署上，是很大的效率提升。 Cassandra 作为分布式处理的数据库，IO 性能也是非常关键的考量要点之一，而比较高效的写入性能意味着 Cassandra 可以应对大量写入、统计和分析的应用场景。但相对应的，读取性能则需要进行一定程度的优化。 Cassandra 作为 NoSQL 数据库，其建表操作还有设计逻辑与传统关系型数据库有比较大的差异。由于没有 Join 操作，在建表时需要考虑各种各样的因素。不过在熟悉 NoSQL 的处理逻辑之后，这种处理方式在大数据环境下更加便于处理。 Open The Box 打开盒子于是这里，简单了解过 Cassandra 以后，让我们部署一下 Cassandra 服务。 由于 Cassandra 是集群数据库，所以大部分情况都需要在云端进行操作。 Aliyun 的 Cassandra 服务就可以满足绝大部分的需求。 那么如果，我们需要在本地跑一个简单的测试用数据库，该怎么做呢？ 首先是我的环境： Object Version OS. Ubuntu 20.04 JVM. Open-JDK-1.8.0_292 Cassandra apache-cassandra-3.11.10-bin.tar.gz 在安装 Cassandra 前需要确认 Java 环境。 1$ java -version 假如没有 JVM， 直接运行 Cassandra 会报以下的错误： 1Cassandra 3.0 and later require Java 8u40 or later. 安装 JDK 的方法（JRE 也行，不过因为本人会做 JAVA 开发，因此会需要用上 JDK）： 12$ sudo apt-get update$ sudo apt-get install openjdk-8-jdk # 别忘了更改环境变量 在配置好环境以后，我们就可以开始安装 Cassandra 了： 123$ wget https://mirrors.bfsu.edu.cn/apache/cassandra/3.11.10/apache-cassandra-3.11.10-bin.tar.gz$ # wget https://mirrors.tuna.tsinghua.edu.cn/apache/cassandra/3.11.10/apache-cassandra-3.11.10-bin.tar.gz # 你可能需要清华源$ tar -zxvf apache-cassandra-3.11.10-bin.tar.gz 解压后的目录为 apache-cassandra-3.11.10-bin， 现在让我们来试一试： 12$ cd apache-cassandra-3.11.10-bin/bin$ cassandra # 一切从这里开始 在一长串的处理，一箩筐的日志以后，假如没有报 error，那么 Cassandra 的本地服务就已经启动了。现在，让我们通过 cqlsh 来连接数据库。cqlsh 也在 bin 文件夹内 12345$ ./cqlshConnected to Test Cluster at 127.0.0.1:9042.[cqlsh 5.0.1 | Cassandra 3.11.10 | CQL spec 3.4.4 | Native protocol v4]Use HELP for help.cqlsh &gt; 简单尝试一下： 123cqlsh &gt; DESCRIBE KEYSPACES;system_traces system_schema system_auth system system_distributed 那么到这里，Cassandra 的本地环境算是搭建完成了，需要远程连接云端 Cassandra 数据库的话，请这样写： 1$ ./cqlsh -u &#x27;username&#x27; -p &#x27;password&#x27; your.cassandra.server.com 8888 切记，Cassandra 默认只允许本地连接，如果需要远程连接，请到服务器端更改 cassandra/conf 下 cassandra.yaml 的配置。如果遇到 Last error: Connection refused，可以参看 这个帖子。 SQL 到 CQL我会推荐直接查看 w3cSchool。如果有耐心读英文的话，官方文档 也是个不错的参考处。 施工中，或许会懒，将来兴许会有 CQL 的基本用法以上，是鸽子宣言","categories":[{"name":"技术","slug":"computer-science","permalink":"https://ag-elf.github.io/category/computer-science/"},{"name":"Cassandra & Spark","slug":"computer-science/Cassandra-Spark","permalink":"https://ag-elf.github.io/category/computer-science/Cassandra-Spark/"}],"tags":[{"name":"Cassandra","slug":"Cassandra","permalink":"https://ag-elf.github.io/tags/Cassandra/"}]},{"title":"0x03 - 图像识别 学习地图","slug":"0x03-Machine-Learning-1","date":"2021-04-30T02:49:59.000Z","updated":"2021-05-06T07:49:08.867Z","comments":true,"path":"2021/04/30/0x03-Machine-Learning-1/","link":"","permalink":"https://ag-elf.github.io/2021/04/30/0x03-Machine-Learning-1/","excerpt":"","text":"物件识别搭建在 PaddlePaddle 上的物件识别模块，Github: PaddleDetection。 下面是概述图。 Architectures Backbones Components Data Augmentation Two-Stage Detection Faster RCNN FPN Cascade-RCNN Libra RCNN Hybrid Task RCNN PSS-Det One-Stage Detection RetinaNet YOLOv3 YOLOv4 PP-YOLO SSD Anchor Free CornerNet-Squeeze FCOS TTFNet Instance Segmentation Mask RCNN SOLOv2 Face-Detction FaceBoxes BlazeFace BlazeFace-NAS ResNet(&vd) ResNeXt(&vd) SENet Res2Net HRNet Hourglass CBNet GCNet DarkNet CSPDarkNet VGG MobileNetv1/v3 GhostNet Efficientnet Common Sync-BN Group Norm DCNv2 Non-local FPN BiFPN BFP HRFPN ACFPN Loss Smooth-L1 GIoU/DIoU/CIoU IoUAware Post-processing SoftNMS MatrixNMS Speed FP16 training Multi-machine training Resize Flipping Expand Crop Color Distort Random Erasing Mixup Cutmix Grid Mask Auto Augment 希望学起来不会太累、","categories":[{"name":"技术","slug":"computer-science","permalink":"https://ag-elf.github.io/category/computer-science/"},{"name":"机器学习","slug":"computer-science/machine-learning","permalink":"https://ag-elf.github.io/category/computer-science/machine-learning/"}],"tags":[{"name":"机器学习","slug":"machine-learning","permalink":"https://ag-elf.github.io/tags/machine-learning/"}]},{"title":"0x02 - 杂碎","slug":"0x02-Other-things-1","date":"2021-04-29T04:48:25.000Z","updated":"2021-05-06T07:44:04.423Z","comments":true,"path":"2021/04/29/0x02-Other-things-1/","link":"","permalink":"https://ag-elf.github.io/2021/04/29/0x02-Other-things-1/","excerpt":"","text":"0x00 大海大海可以是浪漫， 无垠，无限，渺无边际。 Johnny Boy, Johnny Boy, we are born for stormy weather. Johnny Boy, Johnny Boy, I wish you last farewell. Somewhere out far away, we are sailing on together. Oh Johnny, my, we are leaving tonight. Johnny say Good Bye. ------ From \"Johnny Boy\" By Santiano 说不定去当海盗是个不错的归处。 0x01 朗姆酒如果海盗不打杀，只是在船上， 早期的水手们，因为清水容易变质会致病， 为了保存珍贵的水资源，都喜欢喝朗姆酒。 说不定一船人，天天都醉醺醺的， 横摆着，摇晃着，朗姆酒与啤酒， 这样自由的日子比起打工和上班族，好像更不错。 杨帆，起航—— 需要救命的朗姆，朗姆，朗姆，否则我们将干渴而死！ Wir brauchen Rum, Rum, Rum, Sonst verdursten wir. ------ From \"Es gibt nur Wasser\" By Santiano 0x02 海里有什么有宝藏、有梦想、还有阴魂不散的莫莫拉·莫拉。 真正的文兰或许不会存在，死后也不会回归瓦尔哈拉， 但对于海盗来说，梦想与彼方对于自己来说又有什么关系呢？ 《冰海战记》中对于维京海盗的描写出乎我的意料。 也许烧杀抢掠才该是海盗生活的主旋律，但是阿谢拉特有自己的梦想，远方的文兰，自己的抱负。出身卑贱，背负着罗马人的血脉， 不管是大帝还是托尔芬，大概都会铭记一生吧。 海水是咸，裹挟着苦辣，把所有的一切都蚀刻殆尽。 0x03 彼岸自己珍惜的东西永远只有自己是最珍视的，但大部分情况这就足够了。 毕竟任何人都没有义务，去喜欢别人喜欢的东西。 竟然真的可以在海边钓一整天的鱼，既没有烦躁，也没有愉悦。只是对着那一片汪洋，甩杆，收杆，甩杆，收杆。 越是缝缝补补，错误也就不断累积。或早或晚，来去终有一天，收获罪有应得。 Bug 越多， 错误越多。 「没关系，我自己一个人能行！」听着，像是借口。","categories":[{"name":"碎碎念","slug":"small-talks","permalink":"https://ag-elf.github.io/category/small-talks/"},{"name":"杂七杂八","slug":"small-talks/others","permalink":"https://ag-elf.github.io/category/small-talks/others/"}],"tags":[{"name":"杂七杂八","slug":"others","permalink":"https://ag-elf.github.io/tags/others/"}]},{"title":"0x01 - FFXIV - 01 - 阿猫和阿肥","slug":"0x01-FFXIV-1","date":"2021-04-28T16:49:15.000Z","updated":"2021-05-10T06:59:20.362Z","comments":true,"path":"2021/04/29/0x01-FFXIV-1/","link":"","permalink":"https://ag-elf.github.io/2021/04/29/0x01-FFXIV-1/","excerpt":"","text":"0x01「潮虫，鳞虾，还有拟饵……」 阿猫今天想做柠檬烤鱼，淡淡的酸味让他着迷，但越来越少的鱼饵难倒了他。 这是阿猫来海都的第三天。咸咸的海风，拽着绵绵小雨，在入冬的海都显得格外清冷。神典石上说，钓鱼得用 上好的鱼饵，但鱼只有在天晴的时候，才会在海都上层浮上水面。 「唔，又脱钩了。」 阿猫摇了摇头，收起了鱼竿。他带了一整箱各式各样的鱼饵，但鱼王根本不搭理他，嘲笑着猫的不自量力，翻了几个泡泡游走了。 …… 0x02「嘿~你在做什么？」 被拍了拍肩，正在发呆的尖耳朵拉拉菲尔吓了一跳，站在她后面的高个子猫魅一丝不漏把阳光全都罩住了。她站在猫魅背光的影子里，像是被盯上的猎物。 「呜呜呜，不要吃我呜呜。。。」拉拉菲尔就像兔子一般，委屈得哭了出来。 「哎哎？」猫魅有点摸不着头脑，他只是钓鱼的时候被一股香味吸引了过来。 周围的视线在菲尔的哭声中越发的刺人，猫魅有些慌张。「不吃啦不吃，猫魅族吃拉拉菲尔那么油腻的肉会拉肚子的。」他这么说。 「呜呜呜，你说我油。。。」拉拉菲尔哭得更大声了。 哎呀……猫魅挠了挠头，这可怎么办呢，鱼都被吓跑了。但那个香味究竟是什么呢。 好像包里有应对这种情况的道具？他翻看了一下背包…… 「菲尔，菲尔，你看这是什么。」还在小声的啜泣的拉拉菲尔睁开了哭红的眼睛，猫魅递过来了一个小纸袋子。 「这是什么，是调味料嘛……」哎……猫魅有点晕。「打开看看。」 那是用竹纸包好的一小袋金平糖。拉拉菲尔取了一颗放进嘴里，砸吧砸吧，砂糖和蜂蜜的甜味混杂萦绕在舌尖。真甜啊。。。她不禁低下了头 「呼~这样就好了」，猫魅松了一口气，悄悄把藏在背包里的风信子头花系在菲尔的头上。果然小个子戴上头花才更可爱嘛。 啊~凑近了的猫魅明白过来。从拉拉菲尔的头发，那是薰衣草的味道。淡淡，悠扬，紫色的气味。","categories":[{"name":"碎碎念","slug":"small-talks","permalink":"https://ag-elf.github.io/category/small-talks/"},{"name":"FFXIV","slug":"small-talks/FFXIV","permalink":"https://ag-elf.github.io/category/small-talks/FFXIV/"}],"tags":[{"name":"FFXIV的故事","slug":"FFXIV的故事","permalink":"https://ag-elf.github.io/tags/FFXIV%E7%9A%84%E6%95%85%E4%BA%8B/"}]},{"title":"0x00 - Hexo 建站， Start From Here","slug":"0x00-Hexo-1","date":"2021-04-28T07:39:44.000Z","updated":"2021-05-06T07:42:25.149Z","comments":true,"path":"2021/04/28/0x00-Hexo-1/","link":"","permalink":"https://ag-elf.github.io/2021/04/28/0x00-Hexo-1/","excerpt":"","text":"人生苦短，不造轮子 这是所有日志的起点，第一篇不知所谓但是就是想贴在这里的日志。 作为第一篇的话，这里准备写一写如何利用 Hexo 搭建这个网站。 不过工程正在建设中，如果发现没有写完的话就稍后再来吧~ 0x00 准备工作一切的开始要从安装 Hexo 开始。如果有需要，也可以直接看官方的 文档。npm 是 Nodejs 的包管理工具，所以在此之前先安装 Nodejs 也是相当必要的。 请在 这里 找到 Nodejs 的下载地址，并在运行下面的代码之前安装完成。 1$ npm install hexo-cli -g # 安装 Hexo 接着就是等待 npm 自己完成自己的工作了。 在安装完成后，我们就可以着手第一个网站的搭建。运行下面的脚本来初始化我们的网站。注意！以后我们的网站的根目录就是下面这个 new_site 文件夹了 12$ hexo init new_site # 初始化 Hexo 仓库$ cd new_site 0x01 开始在初始化以后的文件夹内部，惊喜地发现在根目录下多了若干的文件夹。 在 source/_posts 下的 Markdown 文件就是我们的内容文件了。 官方准备了一份 hello-world.md 来协助完成写作的任务。 其实到此为止，已经完成了大部分的工作，接下来只需要运行： 12$ hexo server # 本地服务器开启$ hexo s # 也可以这样简写 你就可以在 http://localhost:4000 看到网站最初的成果了 如果希望将文件保存为静态页面，请运行： 12$ hexo generate # 保存为静态页面$ hexo g # 简写 在根目录下的 public 文件夹内，就是生成的所有网页文件了。 0x02 部署那么现在一切准备就绪，如果我们希望发布到静态网站服务，例如 github pages 或者 gitee pages 上，那么我们可以使用 hexo 的 deployment 功能。 假如我们的目标是 github pages，那么我们首先需要新建一个 github pages 的仓库，请在 这里 找到搭建 github pages 的教程。 一句话概括：新建 Repository, 名字为 username.github.io 。 在 _config.yml 内找到这部分，并且根据自己的情况更改配置 1234deploy: type: &#x27;git&#x27; # Git 方式 repository: https://github.com/username/username.github.io # 仓库地址 branch: master # 主要分支 接下来的事情，hexo 会帮你做好 12$ hexo deploy # 部署至指定位置$ hexo d # 简写 一切就绪，Enjoy~ 0x03 新建想在 Hexo 新建 Post 很简单: 1$ hexo new post new_post # 新建名字叫 new_post 的 post 执行完成后你就可以在 source/_posts 里找到新建的文档了。","categories":[{"name":"技术","slug":"computer-science","permalink":"https://ag-elf.github.io/category/computer-science/"},{"name":"Hexo","slug":"computer-science/Hexo","permalink":"https://ag-elf.github.io/category/computer-science/Hexo/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://ag-elf.github.io/tags/Hexo/"}]},{"title":"Hitokoto","slug":"hitokoto","date":"2021-04-27T12:00:00.000Z","updated":"2021-05-08T01:09:11.811Z","comments":true,"path":"2021/04/27/hitokoto/","link":"","permalink":"https://ag-elf.github.io/2021/04/27/hitokoto/","excerpt":"","text":":D Getting Hitokoto ------ From 「Johnny Boy」 fetch('https://v1.hitokoto.cn') .then(response => response.json()) .then(data => { const hitokoto = document.getElementById('hitokoto') const from = document.getElementById('From') const creator = document.getElementById('creator') hitokoto.href = 'https://hitokoto.cn/?uuid=' + data.uuid hitokoto.innerText = data.hitokoto from.innerText = data.from if(data.from_who != null) { creator.innerText = \"By \"+ data.from_who } }) .catch(console.error) 刷新会给你不一样的“一言”，接口支持：Hitokoto。","categories":[{"name":"碎碎念","slug":"small-talks","permalink":"https://ag-elf.github.io/category/small-talks/"},{"name":"一言","slug":"small-talks/hitokoto","permalink":"https://ag-elf.github.io/category/small-talks/hitokoto/"}],"tags":[{"name":"一言","slug":"hitokoto","permalink":"https://ag-elf.github.io/tags/hitokoto/"}]},{"title":"你好世界，Hello World，ハローワルド","slug":"hello-world","date":"2021-04-27T07:30:44.000Z","updated":"2021-05-06T07:43:51.034Z","comments":true,"path":"2021/04/27/hello-world/","link":"","permalink":"https://ag-elf.github.io/2021/04/27/hello-world/","excerpt":"","text":"写在前面欢迎来到这里，你找到了一个不起眼的攻城师。 关于我网易云音乐后期患者，时不时会犯病，多多包容呐~ 正经工作是一名算法工程师，也许将来的某一天会有自己开源的社区吧hhhh 梦想是有有一个厉害又别致的个人助力AI 工作之余是艾欧泽亚合法光呆，FFXIV洗澡水玩家，可以在下面找到我。 想要做的事有一大箩筐，但是时间又这么少。 「假如不会正则搜索的话，不如就遍历吧~」 关于程序员主攻机器学习的研究生 「笑死，根本不是机器学习，是人类学习 」 关于FFXIVSince 2018。下图为曾经的猫。 如今的拉拉肥。 不如在这里贴一贴曾经的经历吧，来自曾经月雫话剧团的各位们。详情可以去看 月雫剧团录像机EijNim号 也曾经攻略过绝本。感谢过去的队友们~右三绿脖子的猫就是我啦~ 详情可以去看 这个 如今目前是一名只要日子过得去就不准备随便改变的程序员 该如何面对未来呢~ 未来理想型是喜欢自己的人。 不过未来谁又能明白呢，或许想要成为一名努力而又有所成就的人吧","categories":[{"name":"碎碎念","slug":"small-talks","permalink":"https://ag-elf.github.io/category/small-talks/"}],"tags":[]},{"title":"站点日志","slug":"Diary","date":"2021-04-27T04:00:00.000Z","updated":"2021-05-17T01:26:11.657Z","comments":true,"path":"2021/04/27/Diary/","link":"","permalink":"https://ag-elf.github.io/2021/04/27/Diary/","excerpt":"","text":"2021-05-171. 加入友情链接 2021-05-061. 加入字数统计和时间统计 2021-04-281. 更换主题为 Next，调试 Next 各项配置2. 置顶 Hello World 日志3. 更换背景图片，更新日志信息，发布第一份日志 2021-04-271. Hexo 脚本运行，初始化仓库2. 编辑第一份日志，Hello World 提交","categories":[{"name":"技术","slug":"computer-science","permalink":"https://ag-elf.github.io/category/computer-science/"},{"name":"Hexo","slug":"computer-science/Hexo","permalink":"https://ag-elf.github.io/category/computer-science/Hexo/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://ag-elf.github.io/tags/Hexo/"}]}],"categories":[{"name":"技术","slug":"computer-science","permalink":"https://ag-elf.github.io/category/computer-science/"},{"name":"Docker","slug":"computer-science/Docker","permalink":"https://ag-elf.github.io/category/computer-science/Docker/"},{"name":"机器学习","slug":"computer-science/machine-learning","permalink":"https://ag-elf.github.io/category/computer-science/machine-learning/"},{"name":"碎碎念","slug":"small-talks","permalink":"https://ag-elf.github.io/category/small-talks/"},{"name":"FFXIV","slug":"small-talks/FFXIV","permalink":"https://ag-elf.github.io/category/small-talks/FFXIV/"},{"name":"Cassandra & Spark","slug":"computer-science/Cassandra-Spark","permalink":"https://ag-elf.github.io/category/computer-science/Cassandra-Spark/"},{"name":"杂七杂八","slug":"small-talks/others","permalink":"https://ag-elf.github.io/category/small-talks/others/"},{"name":"Hexo","slug":"computer-science/Hexo","permalink":"https://ag-elf.github.io/category/computer-science/Hexo/"},{"name":"一言","slug":"small-talks/hitokoto","permalink":"https://ag-elf.github.io/category/small-talks/hitokoto/"}],"tags":[{"name":"Docker","slug":"Docker","permalink":"https://ag-elf.github.io/tags/Docker/"},{"name":"Jenkins","slug":"Jenkins","permalink":"https://ag-elf.github.io/tags/Jenkins/"},{"name":"Clustering","slug":"Clustering","permalink":"https://ag-elf.github.io/tags/Clustering/"},{"name":"FFXIV的故事","slug":"FFXIV的故事","permalink":"https://ag-elf.github.io/tags/FFXIV%E7%9A%84%E6%95%85%E4%BA%8B/"},{"name":"Cassandra","slug":"Cassandra","permalink":"https://ag-elf.github.io/tags/Cassandra/"},{"name":"机器学习","slug":"machine-learning","permalink":"https://ag-elf.github.io/tags/machine-learning/"},{"name":"杂七杂八","slug":"others","permalink":"https://ag-elf.github.io/tags/others/"},{"name":"Hexo","slug":"Hexo","permalink":"https://ag-elf.github.io/tags/Hexo/"},{"name":"一言","slug":"hitokoto","permalink":"https://ag-elf.github.io/tags/hitokoto/"}]}